// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: refresh_tokens.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRefreshToken = `-- name: CreateRefreshToken :one
INSERT INTO refresh_tokens (
    token,
    user_id,
    expires_at,
    user_agent,
    ip_address
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING token, user_id, created_at, expires_at, revoked_at, revocation_reason, logged_out_at, user_agent, ip_address
`

type CreateRefreshTokenParams struct {
	Token     string
	UserID    pgtype.UUID
	ExpiresAt pgtype.Timestamp
	UserAgent string
	IpAddress string
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, createRefreshToken,
		arg.Token,
		arg.UserID,
		arg.ExpiresAt,
		arg.UserAgent,
		arg.IpAddress,
	)
	var i RefreshToken
	err := row.Scan(
		&i.Token,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.RevocationReason,
		&i.LoggedOutAt,
		&i.UserAgent,
		&i.IpAddress,
	)
	return i, err
}

const getToken = `-- name: GetToken :one
SELECT token, user_id, created_at, expires_at, revoked_at, revocation_reason, logged_out_at, user_agent, ip_address
FROM refresh_tokens
WHERE token = $1
`

func (q *Queries) GetToken(ctx context.Context, token string) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, getToken, token)
	var i RefreshToken
	err := row.Scan(
		&i.Token,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.RevocationReason,
		&i.LoggedOutAt,
		&i.UserAgent,
		&i.IpAddress,
	)
	return i, err
}

const getTokensByIp = `-- name: GetTokensByIp :many
SELECT token, user_id, created_at, expires_at, revoked_at, revocation_reason, logged_out_at, user_agent, ip_address
FROM refresh_tokens
WHERE ip_address = $1
`

func (q *Queries) GetTokensByIp(ctx context.Context, ipAddress string) ([]RefreshToken, error) {
	rows, err := q.db.Query(ctx, getTokensByIp, ipAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RefreshToken
	for rows.Next() {
		var i RefreshToken
		if err := rows.Scan(
			&i.Token,
			&i.UserID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.RevokedAt,
			&i.RevocationReason,
			&i.LoggedOutAt,
			&i.UserAgent,
			&i.IpAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokensByUser = `-- name: GetTokensByUser :many
SELECT token, user_id, created_at, expires_at, revoked_at, revocation_reason, logged_out_at, user_agent, ip_address
FROM refresh_tokens
WHERE user_id = $1
`

func (q *Queries) GetTokensByUser(ctx context.Context, userID pgtype.UUID) ([]RefreshToken, error) {
	rows, err := q.db.Query(ctx, getTokensByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RefreshToken
	for rows.Next() {
		var i RefreshToken
		if err := rows.Scan(
			&i.Token,
			&i.UserID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.RevokedAt,
			&i.RevocationReason,
			&i.LoggedOutAt,
			&i.UserAgent,
			&i.IpAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logOutToken = `-- name: LogOutToken :exec
UPDATE refresh_tokens
SET logged_out_at = CURRENT_TIMESTAMP
WHERE token = $1
`

func (q *Queries) LogOutToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, logOutToken, token)
	return err
}

const revokeToken = `-- name: RevokeToken :exec
UPDATE refresh_tokens
SET revoked_at = CURRENT_TIMESTAMP, revocation_reason = $2
WHERE token = $1
`

type RevokeTokenParams struct {
	Token            string
	RevocationReason pgtype.Text
}

func (q *Queries) RevokeToken(ctx context.Context, arg RevokeTokenParams) error {
	_, err := q.db.Exec(ctx, revokeToken, arg.Token, arg.RevocationReason)
	return err
}

const revokeTokensOfIp = `-- name: RevokeTokensOfIp :exec
UPDATE refresh_tokens
SET revoked_at = CURRENT_TIMESTAMP, revocation_reason = $2
WHERE ip_address = $1
`

type RevokeTokensOfIpParams struct {
	IpAddress        string
	RevocationReason pgtype.Text
}

func (q *Queries) RevokeTokensOfIp(ctx context.Context, arg RevokeTokensOfIpParams) error {
	_, err := q.db.Exec(ctx, revokeTokensOfIp, arg.IpAddress, arg.RevocationReason)
	return err
}

const revokeTokensOfUser = `-- name: RevokeTokensOfUser :exec
UPDATE refresh_tokens
SET revoked_at = CURRENT_TIMESTAMP, revocation_reason = $2
WHERE user_id = $1
`

type RevokeTokensOfUserParams struct {
	UserID           pgtype.UUID
	RevocationReason pgtype.Text
}

func (q *Queries) RevokeTokensOfUser(ctx context.Context, arg RevokeTokensOfUserParams) error {
	_, err := q.db.Exec(ctx, revokeTokensOfUser, arg.UserID, arg.RevocationReason)
	return err
}
